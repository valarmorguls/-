#-
网络IO，会涉及两个对象，一个是用户空间调用IO的进程或者线程,另一个是内核空间的内核系统，比如发生IO操作read时，它会经历两个阶段：
   1.等待数据准备就绪
   2.将数据从内核拷贝到进程或线程中。

1.阻塞IO
   在 linux 中，默认情况下所有的 socket 都是 blocking，一个典型的读操作流
当用户进程调用了 read 这个系统调用，kernel 就开始了 IO 的第一个阶段：准备数据。对于
network io 来说，很多时候数据在一开始还没有到达（比如，还没有收到一个完整的数据包），
这个时候 kernel 就要等待足够的数据到来。而在用户进程这边，整个进程会被阻塞。当 kernel
一直等到数据准备好了，它就会将数据从 kernel 中拷贝到用户内存，然后 kernel 返回结果，
用户进程才解除 block 的状态，重新运行起来。
所以，blocking IO 的特点就是在 IO 执行的两个阶段（等待数据和拷贝数据两个阶段）都被
block 了。
(1).一问一答服务器
   大部分的 socket 接口都是阻塞型的。所谓阻塞型接口是指系统调用（一般是 IO 接口）
不返回调用结果并让当前线程一直阻塞，只有当该系统调用获得结果或者超时出错时才返
回。
   实际上，除非特别指定，几乎所有的 IO 接口 ( 包括 socket 接口 ) 都是阻塞型的。这给
网络编程带来了一个很大的问题，如在调用 send()的同时，线程将被阻塞，在此期间，线程
将无法执行任何运算或响应任何的网络请求。
   一个简单的改进方案是在服务器端使用多线程（或多进程）。多线程（或多进程）的目的
是让每个连接都拥有独立的线程（或进程），这样任何一个连接的阻塞都不会影响其他的连
接。具体使用多进程还是多线程，并没有一个特定的模式。传统意义上，进程的开销要远远
大于线程，所以如果需要同时为较多的客户机提供服务，则不推荐使用多进程；如果单个服
务执行体需要消耗较多的 CPU 资源，譬如需要进行大规模或长时间的数据运算或文件访问，
则进程较为安全。通常，使用 pthread_create ()创建新线程，fork()创建新进程。

