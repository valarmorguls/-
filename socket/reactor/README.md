#11#
网络 IO，会涉及到两个系统对象，一个是用户空间调用 IO 的进程或者线程，另一个是内核
空间的内核系统，比如发生 IO 操作 read 时，它会经历两个阶段：
1. 等待数据准备就绪
2. 将数据从内核拷贝到进程或者线程中。
因为在以上两个阶段上各有不同的情况，所以出现了多种网络 IO 模型

##服务器模型Reactor与Proactor##
对高并发编程，网络连接上的消息处理，可以分为两个阶段：
   1.等待消息准备好、消息处理。
当使用默认的阻塞套接字时（例如上面提到的 1 个线程捆绑处理 1 个连接），往往是把
这两个阶段合而为一，这样操作套接字的代码所在的线程就得睡眠来等待消息准备好，这导
致了高并发下线程会频繁的睡眠、唤醒，从而影响了 CPU 的使用效率。
   高并发编程方法当然就是把两个阶段分开处理。即，等待消息准备好的代码段，与处理
消息的代码段是分离的。当然，这也要求套接字必须是非阻塞的，否则，处理消息的代码段
很容易导致条件不满足时，所在线程又进入了睡眠等待阶段。
##那么问题来了，等待消息准备好这个阶段怎么实现？
线程主动查询，或者让 1 个线程为所有连接而等待！这就是 IO 多路复用了。多路复用就是
处理等待消息准备好这件事的，但它可以同时处理多个连接！它也可能“等待”，所以它也会
导致线程睡眠，然而这不要紧，因为它一对多、它可以监控所有连接。这样，当我们的线程
被唤醒执行时，就一定是有一些连接准备好被我们的代码执行了。
#作为一个高性能服务器程序通常需要考虑处理三类事件： 
I/O 事件，定时事件及信号。
两种高效的事件处理模型：Reactor 和 Proactor。

#Reactor模型 
首先来回想一下普通函数调用的机制：程序调用某函数，函数执行，程序等待，函数将
结果和控制权返回给程序，程序继续处理。Reactor 释义“反应堆”，是一种事件驱动机制。
和普通函数调用的不同之处在于：应用程序不是主动的调用某个 API 完成处理，而是恰恰
相反，Reactor 逆置了事件处理流程，应用程序需要提供相应的接口并注册到 Reactor 上，
如果相应的时间发生，Reactor 将主动调用应用程序注册的接口，这些接口又称为“回调函
数”

Reactor 模式是处理并发 I/O 比较常见的一种模式，用于同步 I/O，中心思想是将所有要
处理的 I/O 事件注册到一个中心 I/O 多路复用器上，同时主线程/进程阻塞在多路复用器上；
一旦有 I/O 事件到来或是准备就绪(文件描述符或 socket 可读、写)，多路复用器返回并将事
先注册的相应 I/O 事件分发到对应的处理器中。
#Reactor 模型有三个重要的组件：
 多路复用器：由操作系统提供，在 linux 上一般是 select, poll, epoll 等系统调用。
 事件分发器：将多路复用器中返回的就绪事件分到对应的处理函数中。
 事件处理器：负责处理特定事件的处理函数。
具体流程如下：
1. 注册读就绪事件和相应的事件处理器；
2. 事件分离器等待事件；
3. 事件到来，激活分离器，分离器调用事件对应的处理器；
4. 事件处理器完成实际的读操作，处理读到的数据，注册新的事件，然后返还控制
权。

Reactor 模式是编写高性能网络服务器的必备技术之一，它具有如下的优点：
 响应快，不必为单个同步时间所阻塞，虽然 Reactor 本身依然是同步的；
 编程相对简单，可以最大程度的避免复杂的多线程及同步问题，并且避免了多线程/进
程的切换开销；
 可扩展性，可以方便的通过增加 Reactor 实例个数来充分利用 CPU 资源；
 可复用性，reactor 框架本身与具体事件处理逻辑无关，具有很高的复用性；
Reactor 模型开发效率上比起直接使用 IO 复用要高，它通常是单线程的，设计目标是
希望单线程使用一颗 CPU 的全部资源，但也有附带优点，即每个事件处理中很多时候可以
不考虑共享资源的互斥访问。可是缺点也是明显的，现在的硬件发展，已经不再遵循摩尔定
律，CPU 的频率受制于材料的限制不再有大的提升，而改为是从核数的增加上提升能力，
当程序需要使用多核资源时，Reactor 模型就会悲剧, 为什么呢？
如果程序业务很简单，例如只是简单的访问一些提供了并发访问的服务，就可以直接开
启多个反应堆，每个反应堆对应一颗 CPU 核心，这些反应堆上跑的请求互不相关，这是完
全可以利用多核的。例如 Nginx 这样的 http 静态服务器。

